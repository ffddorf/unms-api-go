// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Model32 model 32
// swagger:model Model 32
type Model32 struct {

	// Custom description text
	// Required: true
	// Max Length: 25
	Comment *string `json:"comment"`

	// Set to true if rule is enabled
	// Required: true
	Enabled *bool `json:"enabled"`

	// IPv4 address of the target LAN device
	// Required: true
	LanAddress *string `json:"lanAddress"`

	// lan port
	// Required: true
	LanPort LanPort `json:"lanPort"`

	// Forwarded protocols
	// Required: true
	// Enum: [tcpudp tcp udp]
	Protocol *string `json:"protocol"`

	// wan port
	// Required: true
	WanPort WanPort `json:"wanPort"`
}

// Validate validates this model 32
func (m *Model32) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanPort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWanPort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model32) validateComment(formats strfmt.Registry) error {

	if err := validate.Required("comment", "body", m.Comment); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", string(*m.Comment), 25); err != nil {
		return err
	}

	return nil
}

func (m *Model32) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *Model32) validateLanAddress(formats strfmt.Registry) error {

	if err := validate.Required("lanAddress", "body", m.LanAddress); err != nil {
		return err
	}

	return nil
}

func (m *Model32) validateLanPort(formats strfmt.Registry) error {

	if err := validate.Required("lanPort", "body", m.LanPort); err != nil {
		return err
	}

	if err := m.LanPort.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("lanPort")
		}
		return err
	}

	return nil
}

var model32TypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tcpudp","tcp","udp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model32TypeProtocolPropEnum = append(model32TypeProtocolPropEnum, v)
	}
}

const (

	// Model32ProtocolTcpudp captures enum value "tcpudp"
	Model32ProtocolTcpudp string = "tcpudp"

	// Model32ProtocolTCP captures enum value "tcp"
	Model32ProtocolTCP string = "tcp"

	// Model32ProtocolUDP captures enum value "udp"
	Model32ProtocolUDP string = "udp"
)

// prop value enum
func (m *Model32) validateProtocolEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, model32TypeProtocolPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Model32) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *Model32) validateWanPort(formats strfmt.Registry) error {

	if err := validate.Required("wanPort", "body", m.WanPort); err != nil {
		return err
	}

	if err := m.WanPort.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("wanPort")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Model32) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Model32) UnmarshalBinary(b []byte) error {
	var res Model32
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
