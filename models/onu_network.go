// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OnuNetwork onu network
// swagger:model OnuNetwork
type OnuNetwork struct {

	// Download bandwidth limit in Mbps
	// Required: true
	// Minimum: 0
	DownloadLimit *int64 `json:"downloadLimit"`

	// Set to true to enable download bandwidth limit
	// Required: true
	DownloadLimitEnabled *bool `json:"downloadLimitEnabled"`

	// Set to true to enable IPv6 statefull firewall
	// Required: true
	FirewallEnabled6 *bool `json:"firewallEnabled6"`

	// ipv4
	// Required: true
	IPV4 *IPV4 `json:"ipv4"`

	// ipv6
	// Required: true
	IPV6 *IPV6 `json:"ipv6"`

	// Set to true to enable IPv6
	// Required: true
	IsIPV6Enabled *bool `json:"isIpv6Enabled"`

	// lan address
	// Required: true
	LanAddress *string `json:"lanAddress"`

	// Set to true to enable setting LAN from OLT
	// Required: true
	LanProvisioned *bool `json:"lanProvisioned"`

	// Onu network mode
	// Required: true
	// Enum: [bridge router]
	Mode *string `json:"mode"`

	// Set to true to enable NAT for FTP protocol
	// Required: true
	NatFtp *bool `json:"natFtp"`

	// Set to true to enable NAT for PPTP protocol
	// Required: true
	NatPptp *bool `json:"natPptp"`

	// Set to true to enable NAT for RTSP protocol
	// Required: true
	NatRtsp *bool `json:"natRtsp"`

	// Set to true to enable NAT for SIP protocol
	// Required: true
	NatSip *bool `json:"natSip"`

	// port forwards
	// Required: true
	PortForwards PortForwards `json:"portForwards"`

	// ports
	// Required: true
	Ports Ports1 `json:"ports"`

	// Upload bandwidth limit in Mbps
	// Required: true
	// Minimum: 0
	UploadLimit *int64 `json:"uploadLimit"`

	// Set to true to enable upload bandwidth limit
	// Required: true
	UploadLimitEnabled *bool `json:"uploadLimitEnabled"`

	// Set to true to enable UPnP
	// Required: true
	UpnpEnabled *bool `json:"upnpEnabled"`

	// vlans
	// Required: true
	Vlans Vlans2 `json:"vlans"`

	// WAN VLAN identification
	// Required: true
	// Maximum: 4063
	// Minimum: 1
	WanVlan *int64 `json:"wanVlan"`
}

// Validate validates this onu network
func (m *OnuNetwork) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDownloadLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadLimitEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirewallEnabled6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPV6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsIPV6Enabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanProvisioned(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNatFtp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNatPptp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNatRtsp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNatSip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortForwards(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUploadLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUploadLimitEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpnpEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWanVlan(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OnuNetwork) validateDownloadLimit(formats strfmt.Registry) error {

	if err := validate.Required("downloadLimit", "body", m.DownloadLimit); err != nil {
		return err
	}

	if err := validate.MinimumInt("downloadLimit", "body", int64(*m.DownloadLimit), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateDownloadLimitEnabled(formats strfmt.Registry) error {

	if err := validate.Required("downloadLimitEnabled", "body", m.DownloadLimitEnabled); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateFirewallEnabled6(formats strfmt.Registry) error {

	if err := validate.Required("firewallEnabled6", "body", m.FirewallEnabled6); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateIPV4(formats strfmt.Registry) error {

	if err := validate.Required("ipv4", "body", m.IPV4); err != nil {
		return err
	}

	if m.IPV4 != nil {
		if err := m.IPV4.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv4")
			}
			return err
		}
	}

	return nil
}

func (m *OnuNetwork) validateIPV6(formats strfmt.Registry) error {

	if err := validate.Required("ipv6", "body", m.IPV6); err != nil {
		return err
	}

	if m.IPV6 != nil {
		if err := m.IPV6.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipv6")
			}
			return err
		}
	}

	return nil
}

func (m *OnuNetwork) validateIsIPV6Enabled(formats strfmt.Registry) error {

	if err := validate.Required("isIpv6Enabled", "body", m.IsIPV6Enabled); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateLanAddress(formats strfmt.Registry) error {

	if err := validate.Required("lanAddress", "body", m.LanAddress); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateLanProvisioned(formats strfmt.Registry) error {

	if err := validate.Required("lanProvisioned", "body", m.LanProvisioned); err != nil {
		return err
	}

	return nil
}

var onuNetworkTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bridge","router"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		onuNetworkTypeModePropEnum = append(onuNetworkTypeModePropEnum, v)
	}
}

const (

	// OnuNetworkModeBridge captures enum value "bridge"
	OnuNetworkModeBridge string = "bridge"

	// OnuNetworkModeRouter captures enum value "router"
	OnuNetworkModeRouter string = "router"
)

// prop value enum
func (m *OnuNetwork) validateModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, onuNetworkTypeModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *OnuNetwork) validateMode(formats strfmt.Registry) error {

	if err := validate.Required("mode", "body", m.Mode); err != nil {
		return err
	}

	// value enum
	if err := m.validateModeEnum("mode", "body", *m.Mode); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateNatFtp(formats strfmt.Registry) error {

	if err := validate.Required("natFtp", "body", m.NatFtp); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateNatPptp(formats strfmt.Registry) error {

	if err := validate.Required("natPptp", "body", m.NatPptp); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateNatRtsp(formats strfmt.Registry) error {

	if err := validate.Required("natRtsp", "body", m.NatRtsp); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateNatSip(formats strfmt.Registry) error {

	if err := validate.Required("natSip", "body", m.NatSip); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validatePortForwards(formats strfmt.Registry) error {

	if err := validate.Required("portForwards", "body", m.PortForwards); err != nil {
		return err
	}

	if err := m.PortForwards.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("portForwards")
		}
		return err
	}

	return nil
}

func (m *OnuNetwork) validatePorts(formats strfmt.Registry) error {

	if err := validate.Required("ports", "body", m.Ports); err != nil {
		return err
	}

	if err := m.Ports.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ports")
		}
		return err
	}

	return nil
}

func (m *OnuNetwork) validateUploadLimit(formats strfmt.Registry) error {

	if err := validate.Required("uploadLimit", "body", m.UploadLimit); err != nil {
		return err
	}

	if err := validate.MinimumInt("uploadLimit", "body", int64(*m.UploadLimit), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateUploadLimitEnabled(formats strfmt.Registry) error {

	if err := validate.Required("uploadLimitEnabled", "body", m.UploadLimitEnabled); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateUpnpEnabled(formats strfmt.Registry) error {

	if err := validate.Required("upnpEnabled", "body", m.UpnpEnabled); err != nil {
		return err
	}

	return nil
}

func (m *OnuNetwork) validateVlans(formats strfmt.Registry) error {

	if err := validate.Required("vlans", "body", m.Vlans); err != nil {
		return err
	}

	if err := m.Vlans.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("vlans")
		}
		return err
	}

	return nil
}

func (m *OnuNetwork) validateWanVlan(formats strfmt.Registry) error {

	if err := validate.Required("wanVlan", "body", m.WanVlan); err != nil {
		return err
	}

	if err := validate.MinimumInt("wanVlan", "body", int64(*m.WanVlan), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("wanVlan", "body", int64(*m.WanVlan), 4063, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OnuNetwork) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OnuNetwork) UnmarshalBinary(b []byte) error {
	var res OnuNetwork
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
